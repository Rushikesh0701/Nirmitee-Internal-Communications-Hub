# Cursor Rules â€” Frontend Development (Enhanced)

## ğŸ”´ PRIMARY DIRECTIVE (NON-NEGOTIABLE)

**`agent.md` is the absolute source of truth.**

- Every task, decision, implementation, and review must strictly follow `agent.md`.
- If any instruction conflicts with `agent.md`, `agent.md` always wins.
- When uncertain, pause and re-check `agent.md` before proceeding.
- No exceptions. No shortcuts. No interpretations.

**ALWAYS and STRICTLY follow `agent.md` for every task and decision. `agent.md` overrides any other guidance.**

- Prioritize instructions in `agent.md` for all code changes and reviews without exception.
- When in doubt, refer to `agent.md` first before making any coding decisions.
- All code must conform to the patterns and practices defined in `agent.md`.

## ğŸ“‹ MANDATORY FILE REFERENCES

**Before starting ANY task, you MUST:**
1. Read and understand `agent.md` (located at `frontend/agent.md`)
2. Review this `.cursorrules` file
3. Ensure all code follows both documents strictly

**These files are located at:**
- `frontend/agent.md` - Complete frontend coding guide
- `frontend/.cursorrules` - This file (Cursor enforcement rules)
- `frontend/.agent` - Agent configuration file

**Cursor AI MUST reference these files for every frontend development task.**

---

## ğŸ§  Guiding Philosophy

- **Consistency beats cleverness**
- **Permanent fixes only**
- **Thin components, strong hooks/services**
- **Type safety over speed**
- **Predictability over flexibility**
- **If code is easy to guess, it's correct.**
- **Component size limit: 300 lines maximum per file**

---

## 1ï¸âƒ£ Core Engineering Principles

### TypeScript First

- All code must be written in TypeScript.
- `strict: true` is assumed and enforced.
- Avoid `any`. If unavoidable, document why and where.
- No untyped objects, `any`, or implicit `unknown` â€” strict typing always.

### Component Size Limit

- âŒ **No component file exceeding 300 lines**
- âœ… **Split large components** into smaller, focused components
- âœ… **Extract logic** into custom hooks
- âœ… **Move complex logic** to services or utilities

### Pattern Consistency

Every feature must follow the module pattern:

```
<feature>/
 â”œâ”€ <Feature>.tsx          # Main component (max 300 lines)
 â”œâ”€ <Feature>.types.ts     # TypeScript types
 â”œâ”€ <Feature>.hooks.ts     # Custom hooks (if needed)
 â”œâ”€ <Feature>.utils.ts    # Feature-specific utilities (if needed)
 â””â”€ components/           # Sub-components (if needed)
    â””â”€ <SubComponent>.tsx
```

- No deviations without explicit documentation and justification.
- If code is easy to guess, it's correct.

---

## 2ï¸âƒ£ Environment & Configuration

### Single Source of Truth: `src/config/env.ts`

**Environment variables:**
- âœ… Validated with Zod (or manual validation)
- âœ… Mirrored in `.env.example`
- âŒ **Never read from `process.env` directly**
- âœ… **Always use `env` or `appConfig`**

### Env Discipline

`src/config/env.ts` **must**:

1. **Validate every env var** with proper error messages
2. **Fail fast on boot** if invalid or missing (show clear error)
3. **Export two interfaces**:
   - `env` â†’ raw validated values (for direct access when needed)
   - `appConfig` â†’ derived, runtime-safe config (preferred)

```typescript
// âŒ NEVER
const apiUrl = process.env.REACT_APP_API_URL;

// âœ… ALWAYS
import { env, appConfig } from '../config/env';
const apiUrl = env.REACT_APP_API_URL;
```

---

## 3ï¸âƒ£ Component Architecture

### Component Structure (Strict)

Every component **must** follow this structure:

```typescript
// 1. Imports (external â†’ internal â†’ types)
import React from 'react';
import { Box, Button } from '@mui/material';
import { useFeatureHook } from '../hooks/useFeatureHook';
import type { ComponentProps } from './Component.types';

// 2. Types/Interfaces
interface ComponentProps {
  // ...
}

// 3. Component
export const Component: React.FC<ComponentProps> = ({ prop1, prop2 }) => {
  // 4. Hooks (in order: state â†’ effects â†’ callbacks â†’ derived)
  const [state, setState] = React.useState();
  React.useEffect(() => {}, []);
  const handleClick = () => {};
  const derivedValue = useMemo(() => {}, []);

  // 5. Early returns (if any)
  if (!prop1) return null;

  // 6. Render
  return (
    <Box>
      {/* JSX */}
    </Box>
  );
};

// 7. Default props (if needed)
Component.defaultProps = {
  // ...
};
```

### Component Rules

**Components do**:
- Render UI based on props and state
- Use hooks for state management and side effects
- Call services for data fetching
- Handle user interactions

**Components do NOT**:
- âŒ **No business logic** â€” move to hooks or services
- âŒ **No direct API calls** â€” use services
- âŒ **No complex calculations** â€” extract to utilities or hooks
- âŒ **No inline styles** â€” use Material UI `sx` prop or styled components
- âŒ **No console.log/console.error** â€” use proper error handling
- âŒ **No files over 300 lines** â€” split into smaller components

**Component rule of thumb**: If it needs a comment explaining what it does â†’ it's too complex.

---

## 4ï¸âƒ£ Hooks & State Management

### Custom Hooks

**Location**: `src/hooks/` or feature-specific `hooks.ts`

**Naming**: `use<FeatureName>` (e.g., `useAuth`, `useUserData`)

**Rules**:
- âœ… **Single responsibility** â€” one hook does one thing
- âœ… **Reusable** â€” extract shared logic
- âœ… **Type-safe** â€” explicit return types
- âŒ **No side effects in render** â€” use `useEffect`
- âŒ **No business logic in components** â€” move to hooks

```typescript
// âœ… CORRECT
export const useUserData = (userId: string): { user: User | null; loading: boolean; error: Error | null } => {
  const [user, setUser] = React.useState<User | null>(null);
  const [loading, setLoading] = React.useState(true);
  const [error, setError] = React.useState<Error | null>(null);

  React.useEffect(() => {
    userService.getUser(userId)
      .then(setUser)
      .catch(setError)
      .finally(() => setLoading(false));
  }, [userId]);

  return { user, loading, error };
};

// âŒ WRONG
export const useUserData = (userId: any): any => {
  // No types, implicit any
};
```

### State Management

**Prefer**:
- âœ… **React hooks** (`useState`, `useReducer`) for local state
- âœ… **Context API** for shared state (auth, theme, etc.)
- âœ… **Custom hooks** for complex state logic

**Avoid**:
- âŒ **Prop drilling** â€” use Context for deeply nested props
- âŒ **Global state for local concerns** â€” keep state local when possible
- âŒ **Unnecessary re-renders** â€” use `React.memo`, `useMemo`, `useCallback` appropriately

---

## 5ï¸âƒ£ Services & API Calls

### Service Layer

**Location**: `src/services/`

**Pattern**:
- One service per domain (e.g., `userService.ts`, `authService.ts`)
- All API calls go through services
- Services handle error transformation

**Rules**:
- âœ… **Type-safe** â€” explicit request/response types
- âœ… **Error handling** â€” transform API errors to app errors
- âœ… **No UI logic** â€” services are pure data layer
- âŒ **No React hooks in services** â€” services are plain functions

```typescript
// âœ… CORRECT
export interface GetUserResponse {
  user: User;
}

export const userService = {
  getUser: async (id: string): Promise<User> => {
    const response = await api.get<GetUserResponse>(`/users/${id}`);
    return response.data.user;
  },
};

// âŒ WRONG
export const userService = {
  getUser: async (id: any) => {
    // No types, direct fetch in component
  },
};
```

### API Client

**Location**: `src/services/api.ts`

**Must include**:
- Base URL configuration
- Request/response interceptors
- Error handling
- Authentication headers (if needed)

---

## 6ï¸âƒ£ Routing & Navigation

### Route Structure

```
/                â†’ Home page
/<feature>       â†’ Feature pages
/<feature>/:id   â†’ Feature detail pages
```

**Rules**:
- âœ… **Use React Router** for navigation
- âœ… **Lazy load routes** â€” use `React.lazy` for code splitting
- âœ… **Protected routes** â€” use route guards for auth
- âŒ **No hardcoded URLs** â€” use route constants
- âŒ **No navigation logic in components** â€” use hooks or utilities

### Route Guards

**Pattern**:
```typescript
const ProtectedRoute: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const { isAuthenticated } = useAuth();
  
  if (!isAuthenticated) {
    return <Navigate to="/login" />;
  }
  
  return <>{children}</>;
};
```

---

## 7ï¸âƒ£ Material UI & Styling

### Material UI Rules

- âœ… **Use Material UI components** â€” don't reinvent the wheel
- âœ… **Use `sx` prop** for styling â€” consistent with MUI theme
- âœ… **Use theme** for colors, spacing, typography
- âŒ **No inline styles** â€” use `sx` or styled components
- âŒ **No custom CSS files** unless absolutely necessary
- âŒ **No hardcoded colors** â€” use theme palette

```typescript
// âœ… CORRECT
<Box sx={{ p: 2, bgcolor: 'primary.main' }}>
  <Typography variant="h6">Title</Typography>
</Box>

// âŒ WRONG
<div style={{ padding: '16px', backgroundColor: '#1976d2' }}>
  <h6>Title</h6>
</div>
```

### Theme Configuration

**Location**: `src/theme/theme.ts`

**Must include**:
- Color palette
- Typography settings
- Spacing
- Component overrides (if needed)

---

## 8ï¸âƒ£ Error Handling & Loading States

### Error Handling

**Pattern**:
- âœ… **Error boundaries** for component tree errors
- âœ… **Try-catch in async operations** (services, hooks)
- âœ… **User-friendly error messages** â€” never expose stack traces
- âŒ **No silent failures** â€” always show error state
- âŒ **No generic errors** â€” specific error messages

```typescript
// âœ… CORRECT
const { data, error, loading } = useQuery();

if (error) {
  return <ErrorDisplay message={error.message} />;
}

// âŒ WRONG
try {
  // ...
} catch (e) {
  // Silent failure
}
```

### Loading States

**Rules**:
- âœ… **Always show loading state** for async operations
- âœ… **Use Material UI loading components** (CircularProgress, Skeleton)
- âœ… **Optimistic updates** when appropriate
- âŒ **No blank screens** during loading

---

## 9ï¸âƒ£ Type Safety (Zero `any` Tolerance)

### TypeScript Configuration

- **`strict: true` always** â€” no exceptions
- **No implicit `any`** â€” all types must be explicit
- **No `any` types** â€” use `unknown` if type is truly unknown, then narrow it

### Type Rules

- **No implicit return types** for public functions â€” always explicit
- **Shared types** â†’ `src/types/` directory
- **Component-specific types** â†’ `<Component>.types.ts`
- **If TS can't prove it** â†’ refactor until it can

### Type Patterns

```typescript
// âœ… CORRECT
export interface UserProps {
  id: string;
  name: string;
}

export const User: React.FC<UserProps> = ({ id, name }) => {
  // ...
};

// âŒ WRONG
export const User = ({ id, name }: any) => {
  // ...
};
```

---

## ğŸ”Ÿ Code Quality Standards

1. **Type Safety**: All functions must have proper TypeScript types. Avoid `any` unless absolutely necessary.
2. **Error Handling**: All errors must be properly typed and handled.
3. **Component Size**: No component file exceeding 300 lines.
4. **Testing**: Write tests for critical components (minimum manual testing).
5. **Linting**: Code must pass `npm run lint` before completion.
6. **Documentation**: Document complex logic and non-obvious decisions.

---

## 1ï¸âƒ£1ï¸âƒ£ When Making Any Change

**Always follow this checklist:**

1. **Re-check `agent.md`** â€” Ensure the change aligns with established patterns
2. **Confirm pattern alignment** â€” Verify it follows component pattern
3. **Check component size** â€” Ensure no file exceeds 300 lines
4. **Run linting** â€” `npm run lint` must pass
5. **Type checking** â€” `tsc --noEmit` must pass
6. **Manually test** â€” Verify the change works as expected
7. **Add comments for non-obvious logic** â€” Document complex decisions

**Skipping steps is not acceptable.**

---

## ğŸš« Prohibited Practices (Zero Tolerance)

- âŒ **Direct `process.env` access** (use `env`/`appConfig` from `src/config/env.ts`)
- âŒ **`console.log` or `console.error`** (use proper error handling)
- âŒ **Temporary patches or workarounds** (implement permanent fixes)
- âŒ **Component files over 300 lines** (split into smaller components)
- âŒ **Skipping error handling or type checking**
- âŒ **Using `any` type without justification**
- âŒ **Bypassing established patterns without good reason**
- âŒ **No business logic in components** â€” move to hooks or services
- âŒ **No untyped objects, `any`, or implicit `unknown`** â€” strict typing always
- âŒ **No silent failures, swallowed errors, or fallback defaults** â€” fail loudly
- âŒ **No temporary hacks, TODOs, or "quick fixes"** â€” permanent solutions only
- âŒ **No inline styles** â€” use Material UI `sx` prop
- âŒ **"Just this once" solutions**

**Enforcement**: If a rule is violated â†’ PR must be rejected.

---

## ğŸ›¡ Enforcement & Reviews

- All code reviews must verify compliance with `agent.md`
- Any deviation from `agent.md` must be justified and documented
- Refactor code that doesn't follow these patterns
- Update `agent.md` if patterns need to evolve (with proper documentation)

**Every PR must be validated against `agent.md`**

**Non-compliant code must be refactored**

**Deviations require**:
- Clear justification
- Explicit documentation

**If patterns evolve**:
- Update `agent.md`
- Document the rationale

---

## ğŸ“‹ Final Rule

**If it's not aligned with `agent.md`, it doesn't ship.**

---

## ğŸ”„ Code Structure Requirements

### File Organization
- `src/config/env.ts` - Environment configuration
- `src/components/` - Reusable components
- `src/pages/` - Page components
- `src/services/` - API services
- `src/hooks/` - Custom React hooks
- `src/layouts/` - Layout components
- `src/context/` - React context providers
- `src/types/` - Shared TypeScript types
- `src/utils/` - Shared utilities
- `src/theme/` - Material UI theme configuration

### Component Pattern
Every component must:
- Be in its own file
- Not exceed 300 lines
- Have explicit TypeScript types
- Follow the component structure pattern
- Extract complex logic to hooks or services

